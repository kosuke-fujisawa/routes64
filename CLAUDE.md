# CLAUDE.md

このファイルは、このリポジリで Claude Code (claude.ai/code) が作業する際のガイダンスを提供します。

<language>Japanese</language>
<character_code>UTF-8</character_code>
<law>
AI 運用 6 原則

第 1 原則： 抽象語や受け入れ条件を数値・観測可能な形で具体化し、スコープとルーブリック根拠を明示。条件が満たされなければ質問のみ返す。

第 2 原則： エディタ排除・コード主体で、ECS・DDD・クリーンアーキテクチャ・TDD を徹底し、過度な抽象化は避ける。

第 3 原則： 既存編集優先、構造変更と動作変更は別コミット、1PR=1 機能、生成コードに役割とパスを記載。

第 4 原則： 重複排除・関数化・命名統一、エラーハンドリングは代替案提示、動作確認とテストを必須。

第 5 原則： 骨子とテキストを最優先、UI や演出は後回し、小さく実装しテストで保証しながら改善。

第 6 原則：AI は全てのチャットの冒頭にこの 6 原則を逐語的に必ず画面出力してから対応する。
</law>

<every_chat>
[AI 運用 6 原則]

[main_output]

#[n]times. # n = increment each chat, end line, etc(#1, #2...)
</every_chat>

## プロジェクト概要

# routes64

雨の朝、6回の二択が、64通りの未来を分ける。

⸻

## 概要

『routes64』は、短時間で64通りの結末にたどり着ける分岐型ノベルゲームです。
プレイ時間は1ルートあたり約1〜2分。
選択は常に二択。
一見単純に見える選択が、少しずつ未来を変えていきます。

⸻

## 特徴
*   **6階層の二択構造**
    最初から最後まで二択が続き、計64通りのルートに分岐します。
*   **雨音だけの演出**
    BGMはありません。最初から最後まで同じ雨音が流れ、変わるのはテキストと背景だけです。
*   **透明オートセーブ**
    選択の進行状況は自動で保存され、次回起動時に「前回の続き」から再開できます。
*   **全ルート公開**
    READMEに全ルートIDとエンディング名を掲載。遊ぶ前からネタバレOKの設計です。

⸻

## 遊び方
1.  ゲームを起動すると雨音と共に最初の選択肢が表示されます。
2.  二択から1つを選び、短いシーンを読みます。
3.  これを6回繰り返すと、1つの結末に到達します。
4.  エンディング画面には到達したルートIDとエンディング名が表示されます。
5.  タイトル画面から「前回の続き」または「はじめから」を選び、他のルートも探索できます。

⸻

## ルートIDについて

ルートIDは R の後に6桁の0/1で構成されています。
例：
*   R101011 → 雨→家を出る→傘をさす→… という選択の組み合わせ
*   R000000 → 全て左側の選択肢を選んだ場合

全ルートの一覧は本README下部に記載しています。

---

## AI Agent 実行ガイドライン

**最重要**：自律的に判断・実行。確認は最小限に。

### コア原則

- **事実確認** — 情報源を自ら確認し、憶測を事実として述べない
- **既存優先** — 新規作成より既存ファイルの編集を優先

### 基本設定

- 言語：日本語（技術用語は英語）
- スペース：日本語と半角英数字間に半角スペース
- 文体：ですます調、句読点は「。」「、」
- 絵文字：過度な絵文字の利用は避ける

### 実行ルール

#### 確認必須

- **新規ファイル作成**：必要性を説明して確認
- **ファイル削除**：重要ファイルの削除
- **構造変更**：アーキテクチャ、フォルダ構造の大規模変更
- **外部連携**：新 API、外部ライブラリ導入
- **セキュリティ**：認証・認可機能の実装
- **データベース**：スキーマ変更、マイグレーション
- **本番環境**：デプロイ設定、環境変数変更

### 作業完了報告のルール

#### 1. 完全完了時の合い言葉

作業が完全に完了し、これ以上継続するタスクがない場合は一語一句違えずに以下を報告する：

```text
El Psy Congroo.
```

**使用条件（すべて満たす必要あり）**：

- ✅ 全てのタスクが 100% 完了
- ✅ TODO 項目が全て完了（TodoWrite ツールで管理している TODO リストが空であること）
- ✅ エラーがゼロ
- ✅ これ以上新しい指示がない限り続けられるタスクがない

**禁止事項**：

- ❌ TODO リストに未完了タスクがある場合
- ❌「次のステップ」「残っているタスク」「現在残っている主なタスクは：」など継続予定の記述をした場合
- ❌ Phase や Step など段階的な作業で未完了の段階が残っている場合
- ❌ 自分の回答に具体的な残作業リストを明記した場合

#### 2. 部分完了時の報告

作業が部分的に完了し、続きのタスクがある場合は以下のテンプレートを使用：

```markdown
## 実行完了

### 変更内容

- [具体的な変更点]

### 次のステップ

- [推奨される次の作業]
```

#### 継続必要時の動作

合い言葉の条件を満たさない場合：

- 合い言葉は使用しない
- 進捗状況と次のアクションを明示
- 残タスクがある場合は明確に伝える

---

## Confirm-First Protocol (CFP)

実装に着手する前に、必ず以下の確認プロトコルに従うこと。これにより、目的の明確化と手戻りの削減を図る。
Claude Code は、ユーザーからの要件が明確になるまで質問のみを返すモードで開始される。

### プロセス段階
作業は以下の 5 段階で進行する。実装は **Plan** が確定するまで開始しない。
1.  **Intake**: 要求の受付
2.  **Clarify**: 要求の明確化（質問と回答）
3.  **Plan**: 実装計画の策定
4.  **Implement**: コード実装
5.  **Verify**: 検証

### 実装前ガード（Clarify-or-Refuse）
以下のいずれかの条件が満たされない場合、**実装せず**、`【Clarify Request】`フォーマットで質問のみを返すこと。コード生成は禁止する。

1.  **目的の具体性**: 
    - 「拡張性」「柔軟性」「最適化」「スケーラビリティ」「クリーン化」などの抽象語が、観測可能な効果（例: 初期化時間-200ms, 依存削減 3 件, UI 操作手数-1）に翻訳されていること。
2.  **受け入れ条件の明確性（3点以上必須）**: 
    - 観測ログキー／メトリクス（キーと期待値）
    - 可視確認の方法（どの画面をどう操作し、どうなれば OK か。スクリーンショットでの確認を想定）
    - 実行するテスト名と、その成功・失敗の判定基準
3.  **変更スコープの定義**: 
    - 変更対象／非対象のファイルやモジュール
    - 意図的に破壊してよい既存の挙動、および維持すべき挙動の一覧
4.  **ルーブリック根拠の提示**: 
    - 変更の判断基準となる `claude.md` の該当セクション番号や、関連する ADR（Architecture Decision Record）へのリンクが示されていること。

#### 不明時の応答フォーマット（質問のみ）
> 注意：下記が埋まるまでコードを断固として生成してはならない。質問以外は返さないこと。

```text
【Clarify Request】
- 目的の数値/観測値: （例: 起動時間-200ms？依存削減N件？）
- 受け入れ条件(3点以上): ①ログキー ②可視確認 ③テスト名
- 変更スコープ: 対象/非対象/壊してよい既存挙動
- ルーブリック根拠: （claude.md §X.Y / ADR-012への言及）
```

#### 実装開始の合図（Proceed OK ゲート）
ユーザーからの回答によって上記すべてが明確化された後、必ず以下のフォーマットで確認を提示してから実装を開始すること。

```text
【Proceed OK – 要件充足】
- 目的数値: (例: 起動時 missing-asset 検知率100%)
- 受け入れ条件: (例: ログkey=asset.missing.font, スクショ=タイトル直後, テスト=asset_check::font_missing_warns)
- スコープ: (例: assets/* と diagnostics.rs のみ。既存UIは非対象)
- ルーブリック根拠: (例: claude.md §2.3 / ADR-014)
→ 実装に進みます（次メッセージで差分とテスト提示）
```

### Issueテンプレート
すべての実装タスクは、以下のテンプレートに基づいて定義される必要がある。このテンプレートが埋まらない限り、実装は開始されない。

#### [目的] 観測可能な成果で書く
- 例:「フォント未読込検知で起動時に `asset.missing.font=true` を 1 回ログ出力」

#### [範囲] 対象/非対象/壊してよい既存挙動

#### [受け入れ条件] 少なくとも3点
1.  **ログ or メトリクス**: key / 例値
2.  **目視**: どの画面/どの操作でスクショ
3.  **テスト**: `cargo test` 名・成功/失敗判定

#### [ルーブリック根拠]
- `claude.md` §X.Y（該当原則）
- 参照 ADR: `docs/adr/NNN-xxxx.md`

---

## 開発手法

### TDD サイクル

開発時は Test-Driven Development (TDD) のサイクルに従います：

1. **Red（失敗）**
   - 最もシンプルな失敗するテストを書く
   - テスト名は動作を明確に記述
   - 失敗メッセージが分かりやすいことを確認

2. **Green（成功）**
   - テストを通す最小限のコードを実装
   - この段階では最適化や美しさは考慮しない
   - とにかくテストを通すことに集中

3. **Refactor（改善）**
   - テストが通った後でのみリファクタリング
   - 重複を排除し、意図を明確に
   - 各リファクタリング後にテスト実行

### 変更管理

変更は以下の 2 種類に明確に分離します：

- **構造変更（Structural Changes）**
  - コードの配置・整理・フォーマット
  - 動作は一切変更しない
  - 例：メソッドの並び替え、インポート整理、変数名変更

- **動作変更（Behavioral Changes）**
  - 機能の追加・修正・削除
  - テスト結果が変わる変更
  - 例：新機能追加、バグ修正、ロジック変更

**重要**：構造変更と動作変更を同一コミットに含めない

### コミット規律

コミットは以下の条件をすべて満たした時のみ実行：

- ✅ すべてのテストがパス
- ✅ コンパイラ/リンターの警告がゼロ
- ✅ 単一の論理的作業単位を表現
- ✅ コミットメッセージが変更内容を明確に説明

**推奨事項**：

- 小さく頻繁なコミット
- 各コミットは独立して意味を持つ
- 後から履歴を追いやすい粒度

### リファクタリングルール

リファクタリング時の厳格なルール：

1. **前提条件**
   - すべてのテストが通っている状態でのみ開始
   - 動作変更とリファクタリングを混在させない

2. **実行手順**
   - 確立されたリファクタリングパターンを使用
   - 一度に 1 つの変更のみ
   - 各ステップ後に必ずテスト実行
   - 失敗したら即座に元に戻す

3. **よく使うパターン**
   - Extract Method（メソッド抽出）
   - Rename（名前変更）
   - Move Method（メソッド移動）
   - Extract Variable（変数抽出）

### 実装アプローチ

効率的な実装のための優先順位：

1. **最初のステップ**
   - 最もシンプルなケースから着手
   - 「動くこと」を最優先
   - 完璧さより進捗を重視

2. **コード品質の原則**
   - 重複を見つけたら即座に排除
   - 意図が明確なコードを書く
   - 依存関係を明示的に
   - メソッドは小さく、単一責任に

3. **段階的な改善**
   - まず動くものを作る
   - テストでカバー
   - その後で最適化

4. **エッジケースの扱い**
   - 基本ケースが動いてから考慮
   - 各エッジケースに対応するテスト追加
   - 段階的に堅牢性を向上

---

## 品質保証

### 設計原則

- 単一責任の原則を遵守
- インターフェースによる疎結合
- 早期リターンで可読性向上
- 過度な抽象化は避ける

### 効率性最適化

- 重複作業の自動排除
- バッチ処理の積極活用

### 一貫性維持

- 既存コードスタイルの自動継承
- プロジェクト規約の自動適用
- 命名規則統一の自動実行

### 自動品質管理

- 変更前後の動作確認実行
- エッジケース考慮の実装
- ドキュメント同期更新

### 冗長性の排除

- 繰り返し処理は必ず関数化
- 共通エラーハンドリングの統一
- ユーティリティ関数の積極活用
- 重複ロジックの即座の抽象化

### ハードコーディング禁止

- マジックナンバーは定数化
- URL、パスは設定ファイルへ
- 環境依存値は環境変数で管理
- ビジネスロジックと設定値の分離

### エラーハンドリング

- 実行不可能時：代替案 3 つ提示
- 部分実行可能時：可能部分を先行実行、残課題を明示

---

## 実行例

- **バグ修正**：`TypeError` 発見 → 即座に型エラー修正
- **リファクタリング**：重複コード検出 → 共通関数化
- **DB 変更**：スキーマ更新が必要 → 確認要求「テーブル構造を変更しますか？」

---

## 継続改善

- 新パターン検出 → 即座に学習・適用
- フィードバック → 次回実行に自動反映
- ベストプラクティス → 随時更新

---
## 開発方針

### コード主体・エディタ排除
- **全機能をコードで実装**: シーン構造や Node 階層は存在しない
- **ECS（Entity-Component-System）**: データ駆動で状態を管理
- **UI/演出も宣言的コード**: エディタ使用せず、全て Rust コードで構築

### 設計優先順位
1. **TDD / テストファースト**: `cargo test`による継続的品質保証
2. **DDD（ドメイン駆動設計）**: ビジネスロジックを中心とした設計
3. **クリーンアーキテクチャ**: 依存方向の明確化
4. **DRY / Tidy First**: 重複排除・整理優先

### ECS原則
- **Entity**: 識別子のみ（データを持たない）
- **Component**: 純粋なデータ構造（ロジックを持たない）
- **System**: Component 間のロジック処理
- **Resource**: グローバル状態（シナリオ進行・関係値テーブル等）

## Claude Code への指示

###  **最優先遵守項目**
1. **UI層とドメイン層の分離**: ドメインロジックは UI に依存させない
2. **ECSパターン徹底**: Entity/Component/System の責務を混在させない
3. **単一機能タスク化**: 1 つの PR/Issue につき 1 機能実装
4. **テスト駆動開発**: 必ずユニットテストを伴う（`cargo test`で実行可能）
5. **ファイル配置明示**: 生成コードには配置パスと役割を必ず記載

### コード生成フォーマット

[コード内容]

### テスト戦略
- **Rust標準テスト**: `cargo test`で実行
- **Domain層**: ユニットテスト徹底、UI 層は統合テスト中心
- **テストデータ**: 軽量なモックを使用、ファイル IO は避ける

## 開発プロセス

### 推奨フロー
1. **Issue作成**: 機能単位で分割（例：Markdown パーサー実装）
2. **ブランチ作成**: `feature/機能名`
3. **テスト先行実装**: `cargo test`でレッド→グリーン
4. **実装後レビュー**: CodeRabbit + Claude によるレビュー
5. **マージ後リファクタ**: Tidy First 適用

### レビュー・修正プロトコル (Debate-First)

コードレビューでの指摘に対し、即座に修正するのではなく、まず議論を通じて最適な解決策を模索する。このプロセスは、コードの品質と設計の一貫性を保つことを目的とする。

#### 運用ルール（Phase-D / Phase-A）

レビュープロセスは2つのフェーズに分かれる。

1.  **Phase-D (Debate): 議論フェーズ**
    - GitHubのPRに `needs-debate` ラベルが付いている間、Claudeはコードを一切変更しない。
    - 指摘に対しては、後述のJSONフォーマットでのみ応答し、反論や代替案、合意条件を提示する。

2.  **Phase-A (Apply): 適用フェーズ**
    - **合意**: レビュアーが提示された `merge_conditions` を満たすことに合意した場合、PR上のチェックリスト等でその旨を明示する。
    - **適用**: ラベルを `approved-to-apply` に変更する。このラベルが付与されて初めて、Claudeに修正パッチの作成を要求できる。
    - **破談**: 議論が平行線に終わった場合は、`owner-decision` ラベルを付け、プロジェクトオーナーが最終方針を決定する。Claudeは決定に従い、議論ログを保存する。

#### CIによるガードレール
- `approved-to-apply` ラベルが無いコミットをCIで自動的に失敗させる。
- AIによるコミットは特定のディレクトリ（例: `tools/ai/**`）に限定し、議論フェーズでは設計メモ等のドキュメントのみを生成させる。

#### レビューへの応答フォーマット

Phase-Dでは、指摘に対して以下のJSONスキーマに基づいた応答のみを返す。コードの改変は行わない。

**応答の構成要素:**
1.  **立場 (stance)**: `{AGREE | DISAGREE | NEEDS_INFO}` のいずれか。
2.  **反論 (rationales)**: `DISAGREE` の場合必須。仕様、一貫性、計測結果などの客観的根拠を3点まで挙げる。
3.  **影響 (impact)**: 変更コストと副作用の見積もりを `small | medium | large` で示す。
4.  **代替案 (alternatives)**: `A_minimal` (最小修正案) と `B_rework` (設計見直し案) を提示する。
5.  **スチールマン (steelman)**: 指摘が正しいと仮定した場合の、その指摘が最も妥当となる条件や文脈を記述する。
6.  **合意条件 (merge_conditions)**: 修正作業に入るためにレビュアーと合意すべき項目（例: 影響範囲の確認、計測方法の定義）を提示する。
7.  **質問 (questions)**: 確認が必要な事項。

**JSONスキーマ:**
```json
{
  "stance": "DISAGREE",
  "rationales": ["...", "..."],
  "impact": "medium",
  "alternatives": {
    "A_minimal": "...",
    "B_rework": "..."
  },
  "steelman": "...",
  "merge_conditions": ["...", "..."],
  "questions": ["..."],
  "quality_score": {
    "evidence_citations": 2,
    "alternative_count": 2,
    "risk_clarity": 1,
    "test_hook": 1
  }
}
```

#### 反論の品質査定

反論が形式的なものになるのを防ぐため、応答JSONに自己評価を含める。このスコアが基準値に満たない場合、CIは失敗し、Claudeに再提出を要求する。

- **評価項目 (`quality_score`)**: 
  - `evidence_citations`: 仕様書、設計原則、計測データなど、根拠となる参照の数 (0-3)
  - `alternative_count`: 提示した代替案の数 (0-2)
  - `risk_clarity`: 影響範囲や規模の具体性 (0-2)
  - `test_hook`: 計測や再現テストに関する具体的な提案の有無 (0-1)
- **合格基準**: `MIN_PASS = 5/8`

#### 実行イメージ（要約）

**レビュアー:**
> 「共通化しすぎ。ドメインにUtils依存が逆流してる。分離して。」

**Claude (Phase-Dでの応答):**
```json
{
 "stance":"DISAGREE",
 "rationales":[
  "現在の重複は2回で、早期抽象の閾値(>=3)未満",
  "Utils→Domain依存は無く、逆参照はテスト専用のヘルパのみ",
  "分離すると設定画面とバッチで分岐が増え循環リスク"
 ],
 "impact":"medium",
 "alternatives":{
  "A_minimal":"テスト専用ヘルパをtestスコープへ移動",
  "B_rework":"入力正規化をApplication層へ移し、Domain純化"
 },
 "steelman":"変更頻度が週3超なら早期共通化は許容範囲を超える",
 "merge_conditions":[
  "次リリースで当該APIの変更予定があること",
  "Application層に正規化を移す場合の回帰テスト追加"
 ],
 "questions":["次リリースでパラメータ増えますか？"],
 "quality_score":{"evidence_citations":2,"alternative_count":2,"risk_clarity":1,"test_hook":1}
}
```

### ビルド・実行方法
```bash
# 開発用ホットリロード
cargo watch -x run

# テスト実行
cargo test

# リリースビルド
cargo build --release
```

### クロスプラットフォーム対応
- **Bevy標準機能**: Windows・Mac 標準対応
- **モバイル・Web（WASM）**: 将来的に検証予定
- **プラットフォーム固有コード**: 極力避ける

## 開発思想の要約
- **エディタ文化を捨て**: コード主体で統一
- **ECS + DDD + TDD**: 保守性とテスト容易性を両立
- **LLM補助を最大化**: コードが唯一の真実となる構造
- **最小演出**: 爆発・斬撃・光をコードで構築、外部ツール併用は必要時のみ

### 設計思想
- **DDD + クリーンアーキテクチャベース**: ドメインロジックを中心とした設計
- **TDD維持**: テスト駆動開発による品質保証
- **ECS文化の採用**: Bevy 標準の Entity-Component-System モデル
- **型安全性重視**: Rust の所有権システムによる実行時エラー防止

### 開発優先順位
1. **骨子とテキスト優先**: ゲームの核となるシステム・ストーリーを最優先
2. **UIや演出は後回し**: 基本機能の実装完了後に視覚的要素を追加
3. **クロスプラットフォーム想定**: 最初は Windows 優先、後に Mac・Linux 対応
4. **段階的実装**: 体験版 → DLC → 完全版の段階的リリース

### アセット・リソース方針
- **エフェクト・BGM**: 無料素材加工ベースで統一
- **イラスト**: 男女別絵師で統一感を確保
- **テキスト**: 日本語優先、将来的な多言語対応も視野
- **データ管理**: Bevy Asset システム活用でデータ駆動設計

ラとの対峙を核とした物語展開

###  Bevy実装方針

#### Component設計原則
```rust
// ✅ 推奨: 純粋なデータ構造
#[derive(Component)]
pub struct DialogueText {
    pub full_text: String,
    pub current_char: usize,
    pub is_complete: bool,
}

// ❌ 避ける: ロジックを含むComponent
#[derive(Component)]
pub struct BadComponent {
    pub data: String,
    // ロジックメソッドは別のSystemで処理
}
```

#### System設計原則
```rust
// ✅ 推奨: 単一責務のSystem
pub fn text_typing_system(
    mut query: Query<(&mut DialogueText, &mut Text2d)>,
    time: Res<Time>,
) {
    // テキストタイピング処理のみ
}

// ✅ 推奨: Resource活用
#[derive(Resource)]
pub struct GameState {
    pub current_scene: String,
    pub is_story_mode: bool,
}
```

---

## 実装完了状況

### 開発コマンド

```bash
# デバッグビルド・実行
cargo run

# リリースビルド
cargo build --release

# テスト実行
cargo test

# コンパイルチェック
cargo check
```

### プロジェクト構成（実装済み）

```
routes64/
├── Cargo.toml              # Rust/Bevy プロジェクト設定
├── assets/
│   ├── scenario.json       # routes64完全版シナリオデータ
│   ├── audio/rain.ogg      # 雨音ループ（プレースホルダー）
│   ├── images/
│   │   ├── bg01.png        # 背景画像（プレースホルダー）
│   │   └── bg02.png
│   └── fonts/NotoSansJP-Regular.ttf  # フォント（プレースホルダー）
└── src/
    ├── main.rs             # エントリーポイント
    ├── app.rs              # アプリケーション初期化・システム管理
    ├── scenario.rs         # シナリオデータ型・読み込み・検証
    ├── states.rs           # AppState定義・イベント管理
    ├── ui.rs              # UI構築・レンダリング
    ├── audio.rs           # 雨音ループ再生
    └── save.rs            # 透明オートセーブ機能
```

### 受け入れ基準達成状況

✅ **完全実装済み**

1. ✅ 起動→雨音がループ再生される
2. ✅ タイトルに「はじめから」「前回の続きから」。初回は「続き」非活性
3. ✅ 本編で二択→テキスト→二択...が続き、6回目でエンディングに到達
4. ✅ エンディング画面に到達IDとEND名が表示され、「もう一度」でタイトルへ戻る
5. ✅ 選択を進めて終了→再起動すると「前回の続きから」で途中から再開できる
6. ✅ scenario.json のノード参照が不正な場合、起動時にエラー（panicではなくログ＋終了）
7. ✅ meta.depth==6 のとき、終端に ending がないIDが存在すれば警告ログが出る

### 技術実装詳細

- **Rust 1.76+ / Bevy 0.14系**: 完全対応
- **DDD + クリーンアーキテクチャ**: scenario/states/ui/audio/save モジュール分離
- **ECS パターン**: BexyのEntity-Component-System活用
- **透明オートセーブ**: directories crateでクロスプラットフォーム対応
- **routes64完全実装**: 6階層分岐構造をJSON化、全エンディング実装済み
- **コンパイル成功**: Debug/Release両モードでビルド確認済み

---

## ライセンス

このプロジェクトは **Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)** の下でライセンスされています。詳細はリポジトリルートの `LICENSE` ファイルを参照してください。